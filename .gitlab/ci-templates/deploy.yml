# Deploy Pipeline Template
# Kubernetes deployment configurations via Helm

# Base deployment template
.deploy-base:
  image: alpine/helm:latest
  variables:
    HELM_EXPERIMENTAL_OCI: 1
  before_script:
    - apk add --no-cache kubectl bash curl jq
    - kubectl config set-cluster k8s --server="${KUBE_URL}"
    - kubectl config set-credentials gitlab --token="${KUBE_TOKEN}"
    - kubectl config set-context default --cluster=k8s --user=gitlab --namespace=${KUBE_NAMESPACE}
    - kubectl config use-context default
    - helm repo add stable https://charts.helm.sh/stable
    - helm repo add bitnami https://charts.bitnami.com/bitnami
    - helm repo update

# Deploy to development
.deploy-dev:
  extends: .deploy-base
  stage: deploy-dev
  environment:
    name: development
    url: https://dev.${BASE_DOMAIN}
    kubernetes:
      namespace: ${KUBERNETES_NAMESPACE_DEV}
  variables:
    ENVIRONMENT: "dev"
    KUBE_NAMESPACE: ${KUBERNETES_NAMESPACE_DEV}
    HELM_VALUES_FILE: "values-dev.yaml"
  script:
    - bash ${CI_PROJECT_DIR}/infrastructure/scripts/ci/deploy-to-k8s.sh dev ${CI_COMMIT_SHORT_SHA}
  only:
    refs:
      - develop
    kubernetes: active

# Deploy to staging
.deploy-staging:
  extends: .deploy-base
  stage: deploy-staging
  environment:
    name: staging
    url: https://staging.${BASE_DOMAIN}
    kubernetes:
      namespace: ${KUBERNETES_NAMESPACE_STAGING}
  variables:
    ENVIRONMENT: "staging"
    KUBE_NAMESPACE: ${KUBERNETES_NAMESPACE_STAGING}
    HELM_VALUES_FILE: "values-staging.yaml"
  script:
    - bash ${CI_PROJECT_DIR}/infrastructure/scripts/ci/deploy-to-k8s.sh staging ${CI_COMMIT_SHORT_SHA}
  when: manual
  only:
    refs:
      - main
    kubernetes: active

# Deploy to production
.deploy-prod:
  extends: .deploy-base
  stage: deploy-prod
  environment:
    name: production
    url: https://${BASE_DOMAIN}
    kubernetes:
      namespace: ${KUBERNETES_NAMESPACE_PROD}
  variables:
    ENVIRONMENT: "prod"
    KUBE_NAMESPACE: ${KUBERNETES_NAMESPACE_PROD}
    HELM_VALUES_FILE: "values-prod.yaml"
  script:
    - bash ${CI_PROJECT_DIR}/infrastructure/scripts/ci/deploy-to-k8s.sh prod ${CI_COMMIT_TAG}
  when: manual
  only:
    refs:
      - tags
    kubernetes: active

# Helm deployment template
.helm-deploy:
  script:
    - |
      helm upgrade --install ${SERVICE_NAME} ./charts/${SERVICE_NAME} \
        --namespace ${KUBE_NAMESPACE} \
        --create-namespace \
        --values ./charts/${SERVICE_NAME}/${HELM_VALUES_FILE} \
        --set image.repository=${CI_REGISTRY_IMAGE}/${SERVICE_NAME} \
        --set image.tag=${IMAGE_TAG} \
        --set image.pullPolicy=Always \
        --set ingress.enabled=true \
        --set ingress.hosts[0].host=${SERVICE_NAME}-${ENVIRONMENT}.${BASE_DOMAIN} \
        --set resources.requests.memory=${MEMORY_REQUEST:-"256Mi"} \
        --set resources.requests.cpu=${CPU_REQUEST:-"100m"} \
        --set resources.limits.memory=${MEMORY_LIMIT:-"512Mi"} \
        --set resources.limits.cpu=${CPU_LIMIT:-"500m"} \
        --set autoscaling.enabled=${AUTOSCALING_ENABLED:-true} \
        --set autoscaling.minReplicas=${MIN_REPLICAS:-2} \
        --set autoscaling.maxReplicas=${MAX_REPLICAS:-10} \
        --wait \
        --timeout 5m

# Blue-green deployment template
.blue-green-deploy:
  extends: .deploy-base
  script:
    - |
      # Deploy to green environment
      helm upgrade --install ${SERVICE_NAME}-green ./charts/${SERVICE_NAME} \
        --namespace ${KUBE_NAMESPACE} \
        --values ./charts/${SERVICE_NAME}/${HELM_VALUES_FILE} \
        --set image.tag=${IMAGE_TAG} \
        --set deployment.slot=green \
        --wait
      
      # Run smoke tests
      bash ${CI_PROJECT_DIR}/infrastructure/scripts/ci/smoke-test.sh ${SERVICE_NAME}-green
      
      # Switch traffic to green
      kubectl patch service ${SERVICE_NAME} \
        -n ${KUBE_NAMESPACE} \
        -p '{"spec":{"selector":{"slot":"green"}}}'
      
      # Scale down blue deployment
      kubectl scale deployment ${SERVICE_NAME}-blue \
        -n ${KUBE_NAMESPACE} \
        --replicas=0

# Canary deployment template
.canary-deploy:
  extends: .deploy-base
  variables:
    CANARY_WEIGHT: 10
  script:
    - |
      # Deploy canary version
      helm upgrade --install ${SERVICE_NAME}-canary ./charts/${SERVICE_NAME} \
        --namespace ${KUBE_NAMESPACE} \
        --values ./charts/${SERVICE_NAME}/${HELM_VALUES_FILE} \
        --set image.tag=${IMAGE_TAG} \
        --set deployment.slot=canary \
        --set replicaCount=1 \
        --wait
      
      # Configure traffic split
      kubectl apply -f - <<EOF
      apiVersion: networking.istio.io/v1beta1
      kind: VirtualService
      metadata:
        name: ${SERVICE_NAME}
        namespace: ${KUBE_NAMESPACE}
      spec:
        hosts:
        - ${SERVICE_NAME}
        http:
        - match:
          - headers:
              canary:
                exact: "true"
          route:
          - destination:
              host: ${SERVICE_NAME}
              subset: canary
            weight: 100
        - route:
          - destination:
              host: ${SERVICE_NAME}
              subset: stable
            weight: $((100 - CANARY_WEIGHT))
          - destination:
              host: ${SERVICE_NAME}
              subset: canary
            weight: ${CANARY_WEIGHT}
      EOF

# Rollback template
.rollback:
  extends: .deploy-base
  script:
    - |
      # Get previous revision
      REVISION=$(helm history ${SERVICE_NAME} -n ${KUBE_NAMESPACE} --max 2 -o json | jq -r '.[1].revision')
      
      # Rollback to previous revision
      helm rollback ${SERVICE_NAME} ${REVISION} \
        --namespace ${KUBE_NAMESPACE} \
        --wait
      
      # Verify rollback
      kubectl rollout status deployment/${SERVICE_NAME} -n ${KUBE_NAMESPACE}

# Database migration template
.db-migration:
  image: migrate/migrate:latest
  before_script:
    - apk add --no-cache postgresql-client
  script:
    - |
      migrate -path ./migrations \
        -database "${DATABASE_URL}" \
        up

# Post-deployment verification
.post-deploy-verify:
  image: curlimages/curl:latest
  script:
    - |
      # Wait for deployment to be ready
      sleep 30
      
      # Health check
      curl -f ${APPLICATION_URL}/health || exit 1
      
      # Readiness check
      curl -f ${APPLICATION_URL}/ready || exit 1
      
      # Basic smoke test
      bash ${CI_PROJECT_DIR}/infrastructure/scripts/ci/post-deploy-test.sh

# Deployment notification
.deploy-notify:
  image: appropriate/curl:latest
  script:
    - |
      # Slack notification
      curl -X POST -H 'Content-type: application/json' \
        --data "{
          \"text\":\"Deployment to ${ENVIRONMENT} completed\",
          \"attachments\":[{
            \"color\":\"good\",
            \"fields\":[
              {\"title\":\"Service\",\"value\":\"${SERVICE_NAME}\",\"short\":true},
              {\"title\":\"Version\",\"value\":\"${IMAGE_TAG}\",\"short\":true},
              {\"title\":\"Environment\",\"value\":\"${ENVIRONMENT}\",\"short\":true},
              {\"title\":\"URL\",\"value\":\"${APPLICATION_URL}\",\"short\":true}
            ]
          }]
        }" \
        ${SLACK_WEBHOOK_URL}

# Multi-region deployment
.multi-region-deploy:
  parallel:
    matrix:
      - REGION: ["us-east-1", "eu-west-1", "ap-southeast-1"]
  extends: .deploy-base
  script:
    - |
      # Set region-specific context
      kubectl config use-context k8s-${REGION}
      
      # Deploy to region
      helm upgrade --install ${SERVICE_NAME} ./charts/${SERVICE_NAME} \
        --namespace ${KUBE_NAMESPACE} \
        --values ./charts/${SERVICE_NAME}/values-${ENVIRONMENT}-${REGION}.yaml \
        --set image.tag=${IMAGE_TAG} \
        --set region=${REGION} \
        --wait